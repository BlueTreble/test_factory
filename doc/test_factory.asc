Test Factory
========
Jim C. Nasby <Jim.Nasby@BlueTreble.com>
v0.0.1, January 2015:
:toc:
:toclevels: 3
:numbered:
Test factory makes it easy to create and retrieve test data in a database.

toc::[]

= Overview
One of the most difficult parts of unit testing a database (or a data-focused application) is how to handle test data. Traditionally there are two ways to do this:

- For each test suite, create all necessary test data. Run tests. Optionally, remove test data.
- Create a hierarchy of test suites that use the data from a previous suite.

These each have significant drawbacks:

#1 is very bad for performance. Constantly creating new data for tests becomes a significant overhead at deeper levels of object nesting. IE: To test generating a customer statement you need invoices, which need invoice line items, and purchase orders (and line items), and customer records.

#2 is much more efficient, but maintaining the dependencies between different tests can be very difficult.

A problem for both methods is how to actually reference test data. "Which customer record do we use for testing really old unpaid invoices?"

test_factory attempts to solve these problems. It provides a simple function (tf.get) that allows you to retrieve test data using a text name as an identifier. If the test data you need doesn't already exist then it is created automatically, and a copy is kept in a real table. That copy is never removed automatically, so retrieving that data later is fast. Dependencies are easily handled in the definition of the test data itself. For example:

----
INSERT INTO invoice(customer_id) VALUES( (tf.get( NULL::customer, 'base' )).customer_id )
----

= Quick Start
Register two Test Sets ("base", and "scratch") for the customer Test Object.

----
SELECT tf.register(
	table_name := 'customer'
	, test_sets :=
    array[
		row(
			'base'
			,
$$INSERT INTO customer VALUES
	( DEFAULT -- customer_id
		, 'email', 'first', 'middle', 'last', 'suffix'
		, 'address', 'city', 'state', 'postal'
	)
	RETURNING *
$$
			)::tf.test_set
		, row(
			'scratch'
			,
$$INSERT INTO customer VALUES
	( DEFAULT
		, 'email2', 'first', 'middle', 'last', 'suffix'
		, 'address', 'city', 'state', 'postal'
	)
	RETURNING *
$$
			)::tf.test_set
	]
);
----

Retrieve test customer data (data will be inserted if it doesn't already exist).

----
SELECT * FROM tf.get( NULL::customer, 'base' );
----

Register a customer invoice. Note that this test set uses the already registered customer test data.

----
SELECT tf.register(
    table_name := 'invoice'
    , test_sets :=
    array[
        row(
            'base'
            ,
$$INSERT INTO invoice VALUES
    ( DEFAULT -- invoice_id
        , (tf.get( NULL::customer, 'base' )).customer_id
        , current_date -- Invoice date
        , current_date + 30 -- Due Date
        , 'PO number'
    )
    RETURNING *
$$
            )::tf.test_set
    ]
);
----

= Test Tables
A Test Table is a table that will contain test data.

= Test Sets
Every Test Table has Test Sets associated with it. Test sets are defined as

----
CREATE TYPE tf.test_set AS (
	set_name		text
	, insert_sql	text
);
----

_set_name_ is used to subsequently refer to the data created by insert_sql.
_insert_sql_ is a command that must return test data rows in the same form as the test object.

Note that _insert_sql_ does not have to be an insert statement. It could be a function, for example. The only requirement is that it returns data in the form of table rows. A function defined as "RETURNS SETOF table_name" would work.

= tf.register()

= tf.get()

= Copyright
Copyright (c) 2015 Jim C. Nasby.
